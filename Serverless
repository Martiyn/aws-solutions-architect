Introduction to Serverless

 - Serverless is a new paradign in which the developers don't have to manage servers anymore
 - They just deploy code (functions)
 - Initially Serverless == FaaS (Function as a Service)
 - Serverless was poineered by AWS Lambda but now also includes anything that is not managed by the user:
    1. Databases
    2. Storage
    3. Messaging
    4. etc...
 - Serverless does not mean that there are no servers, it means you don't manage and provision/see them

 - Serverless in AWS:
 - We have our users, that for example, would get static content from our S3 bucket (delivered as a website)
 - Then, we would login with Amazon Cognito, where our users would have their identity stored
 - This would invoke your REST API via Amazon API Gateway
 - The API Gateway would invoke your Lambda functions
 - The Lambda functions would invoke your DynamoDB

 - Serverless services in AWS are:
    1. AWS Lambda
    2. DynamoDB
    3. AWS Cognito
    4. AWS API Gateway
    5. Amazon S3
    6. SNS & SQS
    7. Kinesis Data Firehose
    8. Aurora Serverless
    9. Step Functions
    10. Fargate

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

AWS Lambda

 - AWS Lambda are Virtual Functions (no servers to manage!)
 - Limited by time (short executions)
 - They run on-demand (only run when invoked)
 - Scaling is automated

 - Benefits of AWS Lambda:
 - Easy pricing:
    1. Pay per request and compute time
    2. Free tier of 1,000,000 Lambda requests and 400,000 GBs of compute time
 - Integrated with the whole AWS suite of services
 - Integrated with many programming languages
 - Easy monitoring through AWS CloudWatch
 - Easy to get more resources per functions (up to 10GB of RAM)
 - Increasing RAM will also improve CPU and network

 - AWS Lambda language support:
 - Node,js (JavaScript)
 - Python
 - Java (java 8 compatible)
 - C# (.NET Core)
 - Golang
 - C# / Powershell
 - Ruby
 - Custom Runtime API (community supported, e.g. Rust)

 - Lambda container image:
    1. The container image must implement the Lambda Runtime API
    2. ECS / Fargate is preferred for running arbitraru Docker images

 - AWS Lambda Integrations:
 - Main ones:
    1. API Gateway (create REST API and invoke functions)
    2. Kinesis (uses Lambda to do data transformations on the fly)
    3. DynamoDB (used to create triggers for Lambda functions upon DB event)
    4. S3 (Lambda function triggers whenever a change is made in S3)
    5. CloudFront (Lambda at edge locations)
    6. CloudWatch Events EventBridge (whenever something happens in the infrastructure and we want to react to it with a Lambda function)
    7. CloudWatch Logs (to stream logs whenever you want with Lambda)
    8. SNS (to react to notifications and SNS topics with Lambda)
    9. SQS (to process messages from your queue with Lambda)
    10. Cognito (react to whenever a user logs in, e.g. to a DB)
 - With Lambda, you can have an Automated and fully Reactive architecture
 - Example: Serverless CRON job
 - You can make an EventBridge rule that triggers every hour and invokes the Lambda Function to perform a task

 - AWS Lambda Pricing:
 - You can find overalll pricing information here: https://aws.amazon.com/lambda/pricing
 - Pay per calls:
    1. First 1,000,000 requests are free
    2. $0.20 per 1 million requests thereafter ($0.0000002 per request)
 - Pay per duration: (in increment of 1 ms) 
    1. 400,000 GB-seconds of compute time per month if FREE
    2. == 400,000 seconds if function is 1 GB RAM
    3. == 3,200,000 seconds if function is 128 MB RAM
    4. After that $1.00 for 600,000 GB-seconds
 - It is usually very cheap to run AWS Lambda, so it is very popular


 - AWS Lambda Limits to know - per region
 - Execution:
    1. Memory allocation: 128 MB - 10 GB (1 MB increments)
    2. Maximum execution time: 900 seconds (15 minutes)
    3. Environment variables (4 KB)
    4. Disk capacity in the "function container" (in /tmp): 512 MB to 10 GB
    5. Concurrency executions: 1000 (can be increased)

 - Deployment:
    1. Lambda function deployment siza (compressed .zip): 50 MB
    2. Size of uncompressed deployment (code + dependencies): 250 MB
    3. Can use the /tmp directory to load other files at startup
    4. Size of environment variables: 4 KB


 - Lambda SnapStart:
 - Improves your Lambda functions performance up to 10x at no extra cost for Java 11 and above
 - Lambda invocation has lifecycle phases
 - Ususally Lambda works as follows:
   Init --> Invoke --> Shutdown
 - When SnapStart is enabled, function is invoked from a pre-initialized state (skips Init phase)
 - When you publish a new version:
    1. Lambda initializes the function
    2. Lambda takes a snapshot of memory and disk state of the initialized function
    3. Snapshot is cached for low-latency access (hence why it's called SnapStart)


 - Customization at the Edge:
 - Many modern applications execute some form of the logic at the edge
 - This is called Edge Functions:
    1. A code that you write and attach to CloudFront distributions
    2. Runs close to your users to minimize latency
 - CloudFront provides two types: CloudFront Functions & Lambda@Edge
 - You don't have to manage any servers
 - Functions are deployed globally
 - Use cases: 
    1. Customize the CDN content
    2. Website Security and Privacy
    3. Dynamic Web Application at the Edge
    4. Search Engine Optimization (SEO)
    5. Intelligently route across origins and data centers
    6. Bot mitigation at the edge
    7. Real-time image transformation
    8. A/B testing
    9. User authentication and authorization
    10. User prioritization
    11. User tracking and analytics
 - Pay only for what you use
 - Fully serverless

 - CloudFront Functions:
 - CloudFront functions are lightweight and written in JavaScript
 - Used for high-scale, latency-sensitive CDN customizations
 - Sub-MS startup times, millions of requests per second
 - Diagram of how requests and responses work:

   Client ---(Viewer Request)---> CloudFront ---(Origin Request)---> Origin ---(Origin Response)---> CloudFront ---(Viewer Response)---> Client

 - Used to change Viewer requests and responses:
    1. Viewer requests: after CloudFront receives a request from a viewer
    2. Viewer response: before CloudFront forwards the response to the viewer
 - Native feature of CloudFront (manage code entirely with CloudFront)

 - Lambda@Edge:
 - Lambda functions written in NodeJS or Python
 - Scales to 1000s of requests per second
 - Used to change CloudFront requests and responses:
    1. Viewe Request - after CloudFront receives a request from a viewer
    2. Origin Request - Before CloudFront forwards the request to the origin
    3. Origin Response - after CloudFront receives the response from the origin
    4. Viewer Response - before CloudFront forwards the response to the viewer
 - Author your functions in one AWS Region (us-east-1), then CloudFront replicates to its locations

 - CloudFront Functions vs. Lambda@Edge
 - CloudFront functions:
    1. Runtime support - JavaScript
    2. # of requests - Millions of requests per second
    3. CloudFront Triggers - Viewer Request/Response
    4. Max. Execution time - < 1 ms
    5. Max. Memory - 2 MB
    6. Total Package Size - 10 KB
    7. Network Access, File System Access - No
    8. Access to the request body - No
    9. Pricing - Free tier available, 1/6th the price of @Edge

 - Lambda@Edge:
    1. Runtime support - NodeJS, Python
    2. # of requests - Thousands of request per second
    3. CloudFront Triggers - Viewer request/response, Origin request/response
    4. Max. Execution time - 5-10 seconds
    5. Max. Memory - 128 MB up to 10 GB
    6. Total Package Size - 1 MB - 50 MB
    7. Network Access, File System Access - Yes
    8. Access to the request body - Yes
    9. Pricing - No free tier, charged per request & duration

 - CloudFront Functions vs. Lambda@Edge - Use Cases
 - CloudFront Functions:
    1. Cache key normalization:
       - Transform request attributes (headers, cookies, query strings, URL) to create an optimal Cache key
    2. Header manipulation:
       - Insert/modify/delete HTTP headers in the request or response
    3. URL rewrites or redirects
    4. Request authentication & authorization:
       - Create and validate user-generated tokens (e.g. JWT) to allow/deny requests

 - Lambda@Edge:
    1. Longer execution time (several ms)
    2. Adjustable CPU or memory
    3. Your code depends on 3rd party libraries (e.g. AWS SDK to access other AWS services)
    4. Network access to use external services for processing
    5. File system access or access to the body of HTTP requests

 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

