Introduction to messaging:

 - AWS Integration & Messaging:
 - When we start deploying multiple apps, they will inevitably need to communicate with each other.
 - There are two patterns of app communication:
    1. Synchronous communication:
       - application to application
       - Buying service <---------------> Shipping service
    2. Asynchronous / Event based communication:
       - application to queue to application
       - Buying service -----> Queue -----> Shipping service

 - Synchronous between applications can be problematic if there are suddens traffic spikes
 - In case you need to encode 1000 videos but usually it's 10 (this would be a major issue)
 - In such cases, it is much better to decouple the applications using:
    1. SQS: queue model
    2. SNS: pub/sub model
    3. Kinesis: real-time streaming model
 - These services can scale independently from the application

-----------------------------------------------------------------------------------------------------------------------

Amazon SQS (simple queue service)

 - A Queue is the core of SQS
 - An SQS queue needs a so-called "producer" (something to send messages to the queue)
 - You can have multiple producers sending messages to the same queue
 - Messages can be customized to be whatever you want (e.g. "process video" or "process order")
 - On the other side of the SQS queue, you have the so-called "consumers"
 - Consumers poll the messages from the queue, after which they process them and delete them from the queue
 - The SQS queue is a service, which is used to decouple your producers and consumers
 - Producer ---(send messages)---> SQS Queue ---(poll messages)---> Consumer

 - Amazon SQS - Standard Queue:
 - Oldest Amazon offering (over 10 years old)
 - Fully managed service, used to decouple applications
 - Attributes:
    1. Unlimited throughput, unlimited number of messages in queue
    2. Default retention of messages: 4 days, maximum of 14 days
    3. Low latency (<10 ms on publish and receive)
    4. Limitation of 256KB per message sent
 - Can have duplicate messages (at least once delivery, occasionally)
 - Can have out of order messages (best effort ordering)

 - SQS - Producing messages:
 - Produced to SQS using the SDK (SendMessage API)
 - The message is persisted in SQS until a consumer deletes it (signalling that it has been processed)
 - Message retention: default 4 days, up to 14 days
 - Example:
    1. Send an order to be processed
    2. Information for the above message would be:
       - Order id
       - Customer id
       - Any other attributes you want
    3. The consumer will then process the message
 - SQS standard: unlimited throughput

 - SQS - Consuming Messages:
 - Consumers (applications that you need to manually write with code)
 - Consumers can run on:
    1. EC2 instances
    2. On-prem servers
    3. AWS Lambda
 - Poll SQS for messages (can receive up to 10 messages at a time)
 - Process messages (e.g.: insert the message in an RDS database)
 - Once message is processed, delete the messages using the DeleteMessage API
 - SQS - Multiple EC2 instances consumers:
    1. Consumers receive and process messages in parallel
    2. At least once delivery (if message is not processed fast enough, it is received by other consumers)
    3. Best-effort message ordering
    4. Consumers delete messages after processing them
    5. We can scale consumers horizontally to improve throughput processing

 - SQS with Auto Scaling Group (ASG):
 - When consumers run on EC2 instances inside an ASG, you can set a metric for scaling
 - Metric can be set with CloudWatch - Queue Length (ApproximateNumberOfMessages)
 - Then an alarm can be set to CloudWatch, which will trigger the ASG to scale out/in
 
 - SQS to decouple between application tiers
 - You can scale application front and back-end per the below:

    requests ---> Front-end web app(in ASG) --(send message)-> SQS queue --(receive messages)-> Back-end processing app(in ASG) --(insert)-> S3 bucket

 - The above solution is efficient and highly scalable

 - SQS - Security:
 - Encryption:
    1. In-flight encryption using HTTPS API
    2. At-rest encryption using KMS keys
    3. Client-side encryption if the client wants to perform encryption/decryption
 - Access controls: IAM policies to regulate access to SQS API
 - SQS Access policies (similar to S3 bucket policies):
    1. Useful for cross-account access to SQS queues
    2. Useful for allowing other services (SNS, S3, ...) to write to an SQS queue

 - Amazon SQS - Message visibility timeout:
 - After a message is polled by a consumer, it becomes invisible to other consumers
 - By default "message visibility timeout" is 30 seconds
 - That means that the message has 30 seconds to be processed
 - After the visibility timeout runs out and the message is not deleted, the message will be received by another consumer
 - A consumer could call the ChangeMessageVisibility API to get more time (to avoid the message being processed twice)
 - If visibility timeout is high (hours), and consumer crashes, re-processing will take time
 - If visibility timeout is too low (seconds), we may get duplicate processing, as the message will be picked up by other consumers
 - Visibility timeout needs to be something reasonable for your application

 - Amazon SQS - Long Polling
 - When a consumer requests messages from the queue, it can optionally "wait" for messages to arrive if there are none left in the queue
 - This is called Long Polling
 - Long polling decreases the number of API calls made to SQS while increasing the efficiency and latency of your application
 - The wait time can be between 1 to 20 sec (20 sec is preferable)
 - Long polling can be enabled at the queue level or at the API level using WaitTimeSeconds

 - Amazon SQS - FIFO Queue:
 - FIFO - first in first out (ordering of messages in the queue)
 - This means that messages will be ordered in the queue and the first message in the queue will be the first message to be processed
 - Limited throughput: 300 msg/s without batching, 3000 msg/s with batching
 - Exactly-once send capability (by removing duplicates)
 - Messages are processed in order by the consumer

 - SQS + Auto Scaling Group (ASG):
 - If the load is too big, some transactions (requests) may be lost
 - SQS can be used as a buffer to DB writes
 - SQS queue is infinitely scalable
 - When used as a buffer, SQS can ensure no transactions are lost
 - SQS can also buffer between application tiers (front and back-end)

-----------------------------------------------------------------------------------------------------------------------
